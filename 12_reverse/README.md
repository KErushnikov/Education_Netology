
# Домашнее задание к занятию «Реверс-инжиниринг»

В качестве результата пришлите ответы на вопросы в личном кабинете студента на сайте [netology.ru](https://netology.ru).

## Задание 1

Чем отличается декомпиляция от дизассемблирования?

*Напишите ответ в свободной форме.*

## Ответ

 Под ***декомпиляцией*** понимается построение программы на языке высокого уровня, эквивалентной исходной программе на языке низкого уровня (языке ассемблера). Под ***дизассемблированием*** понимается построение программы на языке ассемблера, эквивалентной исходной программе в машинном коде. Программа в машинном коде представляется либо в виде исполняемого модуля в стандартном для целевой операционной системы формате (например, для Win32 в формате PE [16], а для Linux – в формате ELF [15]), либо в виде дампа содержимого памяти, либо в виде трассы исполнения программы.
 
 Традиционно *декомпиляция* рассматривается в более широком смысле, а именно, как построение программы на языке высокого уровня по программе в машинном коде. Очевидно, что в такой постановке задача *декомпиляции* поглощает задачу *дизассемблирования*. Такое «широкое» понимание *декомпиляции* излишне, поскольку *дизассемблирование* и *декомпиляция* решают разные по сути задачи, хотя и используют схожие методы (в частности, построение графа потока управления и исполняемого покрытия программы). Так, при ***дизассемблировании*** выполняется трансляция исполняемого файла, представляемого в виде набора машинных команд, в программу на языке ассемблера. При ***декомпиляции*** программа с представления низкого уровня транслируется в представление высокого уровня. Дальнейшим этапом повышения уровня абстракции программы может быть *рефакторинг*, посредством которого из программы на языке С можно, например, получить программу на языке С++.
 
 > ##### Рассмотрим разбиение задач декомпиляции и дизассемблирования на подзадачи. Так, при дизассемблировании требуется решать следующие основные задачи:
 > - Разделение кода и данных. Для каждой ячейки программы (или ячейки памяти дампа) должно быть установлено, хранит ли ячейка исполняемые инструкции или данные. Задача эта сама по себе алгоритмически неразрешима [5] и не всегда может быть решена однозначно (например, в случае самомодифицирующегося кода, динамически подгружаемого кода и т. п.).
 > - Замена абсолютных адресов на символические.
 
 > ##### При декомпиляции должны быть решены следующие основные задачи:
 > - Выделение функций в потоке инструкций.
 > - Выявление параметров и возвращаемых значений.
 > - Восстановление структурных конструкций языка высокого уровня.
 > - Замена всех обращений к памяти на конструкции языка высокого уровня (в частности, сюда входит идентификация обращения к локальным переменным и параметрам и их замена на символические имена, идентификация обращений к массивам и их замена на операции с массивами и т. д.).
 > - Восстановление типов объектов языка высокого уровня, выявленных на предыдущем шаге.

## Задание 2* (необязательное)

Найдите пароль, который требует программа [main1](../12_reverse/main1).
(При вводе правильного пароля будет выведен текст "Welcome!")

## Ответ

Пароль который требует программа [main1](../12_reverse/main1) не ***P@ssword***, как могло бы показаться на первый взгляд, увидев строку в 16-ричном редакторе [Screenshot1.JPG](../12_reverse/Screenshot1.JPG)
Верный же пароль - ***Password*** 
[Screenshot2.JPG](../12_reverse/Screenshot2.JPG)
[Screenshot3.JPG](../12_reverse/Screenshot3.JPG)